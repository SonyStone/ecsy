{"version":3,"file":"ecsy.min.js","sources":["../src/utils/object-pool.ts","../src/component/dummy-object-pool.ts","../src/component/component-manager.ts","../src/utils/get-name.ts","../src/entity/event-dispatcher.ts","../src/entity/query.ts","../src/entity/entity-manager.ts","../src/entity/entity.ts","../src/entity/system-state-component.ts","../src/entity/query-manager.ts","../src/utils/query-key.ts","../src/system/system-manager.ts","../src/system/can-execute.ts","../src/system/clear-events.ts","../src/system/system.ts","../src/world.ts","../src/tag-component.ts","../src/schema/create-type.ts","../src/schema/standard-types.ts","../src/schema/infer-type.ts","../src/not.ts","../src/schema/create-component-class.ts"],"sourcesContent":["import { Pool } from '../pool.interface';\nimport { Resettable } from '../resettable.interface';\n\nexport class ObjectPool<T extends Resettable> implements Pool<T> {\n  count = 0;\n  private freeList: T[] = [];\n\n  private createElement: () => T;\n\n  // @todo Add initial size\n  constructor(\n    objectConstructor: new (...args) => T,\n    initialSize?: number,\n  ) {\n\n    let extraArgs = null;\n\n    if (arguments.length > 1) {\n      extraArgs = Array.prototype.slice.call(arguments);\n      extraArgs.shift();\n    }\n\n    this.createElement = extraArgs\n      ? () => new objectConstructor(...extraArgs)\n      : () => new objectConstructor();\n\n    if (typeof initialSize !== 'undefined') {\n      this.expand(initialSize);\n    }\n  }\n\n  aquire(): T {\n    // Grow the list by 20%ish if we're out\n    if (this.freeList.length <= 0) {\n      this.expand(Math.round(this.count * 0.2) + 1);\n    }\n\n    const item = this.freeList.pop();\n\n    return item;\n  }\n\n  release(item: T): void {\n    if (item.reset) {\n      item.reset();\n    }\n    this.freeList.push(item);\n  }\n\n  private expand(count: number): void {\n    for (let n = 0; n < count; n++) {\n      this.freeList.push(this.createElement());\n    }\n    this.count += count;\n  }\n\n  totalSize(): number {\n    return this.count;\n  }\n\n  totalFree(): number {\n    return this.freeList.length;\n  }\n\n  totalUsed(): number {\n    return this.count - this.freeList.length;\n  }\n}\n","import { Pool } from '../pool.interface';\nimport { Resettable } from '../resettable.interface';\n\nexport class DummyObjectPool<T extends Resettable> implements Pool<T> {\n  count = 0;\n  private used = 0;\n\n  constructor(\n    private objectConstructor: new (...args: any[]) => T\n  ) {}\n\n  aquire(): T {\n    this.used++;\n    this.count++;\n\n    return new this.objectConstructor();\n  }\n\n  release(): void {\n    this.used--;\n  }\n\n  totalSize(): number {\n    return this.count;\n  }\n\n  totalFree(): number {\n    return Infinity;\n  }\n\n  totalUsed(): number {\n    return this.used;\n  }\n}\n","import { Component, ComponentConstructor } from '../component.interface';\nimport { ObjectPool } from '../utils/object-pool';\nimport { Pool } from '../pool.interface';\nimport { DummyObjectPool } from './dummy-object-pool';\n\n// TODO: add removeComponent method\nexport class ComponentManager {\n  componentConstructors = new Set<ComponentConstructor>();\n  componentPool = new Map<ComponentConstructor, Pool<Component>>();\n\n  registerComponent(componentConstructor: ComponentConstructor): void {\n    if (this.componentConstructors.has(componentConstructor)) {\n      console.warn(`Component type: '${componentConstructor.name}' already registered.`);\n\n      return;\n    }\n\n    this.componentConstructors.add(componentConstructor);\n  }\n\n  componentAddedToEntity(componentConstructor: ComponentConstructor): void {\n    if (!this.componentConstructors.has(componentConstructor)) {\n      this.registerComponent(componentConstructor);\n    }\n  }\n\n  getComponentsPool(componentConstructor: ComponentConstructor): Pool<Component> {\n\n    if (!this.componentPool.has(componentConstructor)) {\n\n      if (componentConstructor.prototype.reset) {\n\n        this.componentPool.set(componentConstructor, new ObjectPool(componentConstructor));\n\n      } else {\n        console.warn(\n          `Component '${componentConstructor.name}' won't benefit from pooling because 'reset' method was not implemeneted.`\n        );\n\n        this.componentPool.set(componentConstructor, new DummyObjectPool(componentConstructor));\n      }\n    }\n\n    return this.componentPool.get(componentConstructor);\n  }\n}\n","import { ComponentConstructor } from '../component.interface';\n\n/**\n * Return the name of a component\n */\nexport function getName(componentConstructor: ComponentConstructor) {\n  return componentConstructor.name;\n}\n","import { Component } from '../component.interface';\nimport { Entity } from './entity';\n\ntype Listener = (entity: Entity, component?: Component) => void;\n\n/**\n * EventDispatcher\n */\nexport class EventDispatcher<T> {\n  listeners = new Map<T, Listener[]>();\n\n  stats = {\n    fired: 0,\n    handled: 0\n  };\n\n  constructor() {\n  }\n\n  /**\n   * Add an event listener\n   * @param eventName Name of the event to listen\n   * @param listener Callback to trigger when the event is fired\n   */\n  addEventListener(eventName: T, listener: Listener) {\n    const listeners = this.listeners;\n\n    if (!listeners.has(eventName)) {\n      listeners.set(eventName, []);\n    }\n\n    const listenerArray = listeners.get(eventName);\n\n    if (listenerArray.indexOf(listener) === -1) {\n      listenerArray.push(listener);\n    }\n  }\n\n  /**\n   * Check if an event listener is already added to the list of listeners\n   * @param eventName Name of the event to check\n   * @param listener Callback for the specified event\n   */\n  hasEventListener(eventName: T, listener: Listener) {\n    return (\n      this.listeners.has(eventName) && this.listeners.get(eventName).indexOf(listener) !== -1\n    );\n  }\n\n  /**\n   * Remove an event listener\n   * @param eventName Name of the event to remove\n   * @param listener Callback for the specified event\n   */\n  removeEventListener(eventName: T, listener: Listener) {\n    const listenerArray = this.listeners.get(eventName);\n\n    if (listenerArray !== undefined) {\n      const index = listenerArray.indexOf(listener);\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Dispatch an event\n   * @param eventName Name of the event to dispatch\n   * @param entity (Optional) Entity to emit\n   */\n  dispatchEvent(eventName: T, entity?: Entity, component?: Component) {\n    this.stats.fired++;\n\n    const listenerArray = this.listeners.get(eventName);\n\n    if (listenerArray !== undefined) {\n      const array = listenerArray.slice(0);\n\n      for (const value of array) {\n        value.call(this, entity, component);\n      }\n    }\n  }\n\n  /**\n   * Reset stats counters\n   */\n  resetCounters() {\n    this.stats.fired = this.stats.handled = 0;\n  }\n}\n","import { ComponentConstructor, Components } from '../component.interface';\nimport { Entity } from './entity';\nimport { EventDispatcher } from './event-dispatcher';\n\n// tslint:disable:no-bitwise\n\nexport enum QueryEvents {\n  ENTITY_ADDED,\n  ENTITY_REMOVED,\n  COMPONENT_CHANGED,\n}\n\nexport class Query {\n\n  componentConstructors: ComponentConstructor[] = [];\n  notComponentConstructor: ComponentConstructor[] = [];\n\n  entities: Entity[] = [];\n\n  eventDispatcher = new EventDispatcher<QueryEvents>();\n\n  // This query is being used by a reactive system\n  reactive = false;\n\n  /**\n   * @param componentConstructors List of types of components to query\n   */\n  constructor(\n    componentConstructors: Components[],\n    entities: Entity[],\n    public key: string,\n  ) {\n\n    componentConstructors.forEach((componentConstructor) => {\n      if (typeof componentConstructor === 'object') {\n        this.notComponentConstructor.push(componentConstructor.component);\n      } else {\n        this.componentConstructors.push(componentConstructor);\n      }\n    });\n\n    if (this.componentConstructors.length === 0) {\n      throw new Error('Can\\'t create a query without components');\n    }\n\n    // Fill the query with the existing entities\n    for (const entity of entities) {\n      if (this.match(entity)) {\n\n        // @todo ??? this.addEntity(entity); => preventing the event to be generated\n        entity.queries.push(this);\n        this.entities.push(entity);\n      }\n    }\n  }\n\n  /**\n   * Add entity to this query\n   */\n  addEntity(entity: Entity) {\n    entity.queries.push(this);\n    this.entities.push(entity);\n\n    this.eventDispatcher.dispatchEvent(QueryEvents.ENTITY_ADDED, entity);\n  }\n\n  /**\n   * Remove entity from this query\n   */\n  removeEntity(entity: Entity) {\n    let index = this.entities.indexOf(entity);\n\n    if (~index) {\n      this.entities.splice(index, 1);\n\n      index = entity.queries.indexOf(this);\n      entity.queries.splice(index, 1);\n\n      this.eventDispatcher.dispatchEvent(QueryEvents.ENTITY_REMOVED, entity);\n    }\n  }\n\n  match(entity: Entity) {\n    return (\n      entity.hasAllComponents(this.componentConstructors) &&\n      !entity.hasAnyComponents(this.notComponentConstructor)\n    );\n  }\n\n  toJSON() {\n    return {\n      key: this.key,\n      reactive: this.reactive,\n      components: {\n        included: this.componentConstructors.map(C => C.name),\n        not: this.notComponentConstructor.map(C => C.name)\n      },\n      numEntities: this.entities.length\n    };\n  }\n\n  /**\n   * Return stats for this query\n   */\n  stats() {\n    return {\n      numComponents: this.componentConstructors.length,\n      numEntities: this.entities.length\n    };\n  }\n}\n\n","import { ComponentManager } from '../component';\nimport { ComponentConstructor, Components } from '../component.interface';\nimport { getName } from '../utils';\nimport { ObjectPool } from '../utils/object-pool';\nimport { Entity } from './entity';\nimport { EventDispatcher } from './event-dispatcher';\nimport { Query } from './query';\nimport { QueryManager } from './query-manager';\nimport { SystemStateComponent } from './system-state-component';\n\n// tslint:disable:no-bitwise\n\nexport enum EntityManagerEvents {\n  ENTITY_CREATED,\n  ENTITY_REMOVED,\n  COMPONENT_ADDED,\n  COMPONENT_REMOVE,\n}\n\n/**\n * EntityManager\n */\nexport class EntityManager {\n\n  // All the entities in this instance\n  entities: Entity[] = [];\n\n  eventDispatcher = new EventDispatcher<EntityManagerEvents>();\n  entityPool = new ObjectPool<Entity>(Entity);\n\n  // Deferred deletion\n  entitiesWithComponentsToRemove = new Set<Entity>();\n  entitiesToRemove: Entity[] = [];\n  deferredRemovalEnabled = true;\n\n  numStateComponents = 0;\n\n  constructor(\n    private componentManager: ComponentManager,\n    private queryManager: QueryManager,\n  ) {}\n\n  /**\n   * Create a new entity\n   */\n  createEntity(): Entity {\n    const entity = this.entityPool.aquire();\n\n    entity.alive = true;\n    entity.entityManager = this;\n    this.entities.push(entity);\n    this.eventDispatcher.dispatchEvent(EntityManagerEvents.ENTITY_CREATED, entity);\n\n    return entity;\n  }\n\n  // COMPONENTS\n\n  /**\n   * Add a component to an entity\n   * @param entity Entity where the component will be added\n   * @param componentConstructor Component to be added to the entity\n   * @param values Optional values to replace the default attributes\n   */\n  entityAddComponent(entity: Entity, componentConstructor: ComponentConstructor, values?: { [key: string]: any }): void {\n\n    if (entity.componentTypes.has(componentConstructor)) {\n\n      return;\n    }\n\n    entity.componentTypes.add(componentConstructor);\n\n    if ((componentConstructor as any).__proto__ === SystemStateComponent) {\n      this.numStateComponents++;\n    }\n\n    const componentPool = this.componentManager.getComponentsPool(\n      componentConstructor\n    );\n\n    const componentFromPool = componentPool.aquire();\n\n    entity.components.set(componentConstructor.name, componentFromPool);\n\n    if (values) {\n      if (componentFromPool.copy) {\n        componentFromPool.copy(values);\n      } else {\n        for (const name in values) {\n          if (values.hasOwnProperty(name)) {\n            componentFromPool[name] = values[name];\n          }\n        }\n      }\n    }\n\n    this.queryManager.onEntityComponentAdded(entity, componentConstructor);\n    this.componentManager.componentAddedToEntity(componentConstructor);\n\n    this.eventDispatcher.dispatchEvent(EntityManagerEvents.COMPONENT_ADDED, entity, componentConstructor);\n  }\n\n  /**\n   * Remove a component from an entity\n   * @param entity Entity which will get removed the component\n   * @param componentConstructor Component to remove from the entity\n   * @param immediately If you want to remove the component immediately instead of deferred (Default is false)\n   */\n  entityRemoveComponent(entity: Entity, componentConstructor: ComponentConstructor, immediately?: boolean): void {\n    if (!entity.componentTypes.has(componentConstructor)) {\n\n      return;\n    }\n\n    this.eventDispatcher.dispatchEvent(EntityManagerEvents.COMPONENT_REMOVE, entity, componentConstructor);\n\n    if (immediately) {\n\n      this.entityRemoveComponentSync(entity, componentConstructor);\n\n    } else {\n\n      if (entity.componentTypesToRemove.size === 0) {\n        this.entitiesWithComponentsToRemove.add(entity);\n      }\n\n      entity.componentTypes.delete(componentConstructor);\n      entity.componentTypesToRemove.add(componentConstructor);\n\n      const componentName = getName(componentConstructor);\n      entity.componentsToRemove.set(componentName, entity.components.get(componentName));\n\n      entity.components.delete(componentName);\n\n    }\n\n    // Check each indexed query to see if we need to remove it\n    this.queryManager.onEntityComponentRemoved(entity, componentConstructor);\n\n    if ((componentConstructor as any).__proto__ === SystemStateComponent) {\n      this.numStateComponents--;\n\n      // Check if the entity was a ghost waiting for the last system state component to be removed\n      if (this.numStateComponents === 0 && !entity.alive) {\n        entity.remove();\n      }\n    }\n  }\n\n  entityRemoveComponentSync(entity: Entity, componentConstructor: ComponentConstructor): void {\n    // Remove T listing on entity and property ref, then free the component.\n    entity.componentTypes.delete(componentConstructor);\n    const componentName = getName(componentConstructor);\n    const componentEntity = entity.components.get(componentName);\n    entity.components.delete(componentName);\n\n    this.componentManager.componentPool.get(componentConstructor).release(componentEntity);\n  }\n\n  /**\n   * Remove all the components from an entity\n   * @param entity Entity from which the components will be removed\n   */\n  entityRemoveAllComponents(entity: Entity, immediately?: boolean): void {\n    for (const componentType of entity.componentTypes) {\n      if ((componentType as any).__proto__ !== SystemStateComponent) {\n        this.entityRemoveComponent(entity, componentType, immediately);\n      }\n    }\n  }\n\n  /**\n   * Remove the entity from this manager. It will clear also its components\n   * @param entity Entity to remove from the manager\n   * @param immediately If you want to remove the component immediately instead of deferred (Default is false)\n   */\n  removeEntity(entity: Entity, immediately?: boolean): void {\n    const index = this.entities.indexOf(entity);\n\n    if (!~index) { throw new Error('Tried to remove entity not in list'); }\n\n    entity.alive = false;\n\n    if (this.numStateComponents === 0) {\n      // Remove from entity list\n      this.eventDispatcher.dispatchEvent(EntityManagerEvents.ENTITY_REMOVED, entity);\n      this.queryManager.onEntityRemoved(entity);\n      if (immediately === true) {\n        this.releaseEntity(entity, index);\n      } else {\n        this.entitiesToRemove.push(entity);\n      }\n    }\n\n    this.entityRemoveAllComponents(entity, immediately);\n  }\n\n  private releaseEntity(entity: Entity, index): void {\n    this.entities.splice(index, 1);\n\n    // Prevent any access and free\n    entity.entityManager = null;\n    this.entityPool.release(entity);\n  }\n\n  /**\n   * Remove all entities from this manager\n   */\n  removeAllEntities(): void {\n    for (let i = this.entities.length - 1; i >= 0; i--) {\n      this.removeEntity(this.entities[i]);\n    }\n  }\n\n  processDeferredRemoval(): void {\n    if (!this.deferredRemovalEnabled) {\n      return;\n    }\n\n    for (const entity of this.entitiesToRemove) {\n      const index = this.entities.indexOf(entity);\n      this.releaseEntity(entity, index);\n    }\n\n    this.entitiesToRemove.length = 0;\n\n    for (const entity of this.entitiesWithComponentsToRemove) {\n      for (const componentTypeToRemove of entity.componentTypesToRemove) {\n\n        const componentName = getName(componentTypeToRemove);\n\n        const component = entity.componentsToRemove.get(componentName);\n        entity.componentsToRemove.delete(componentName);\n\n        this.componentManager.componentPool.get(componentTypeToRemove).release(component);\n      }\n\n      entity.componentTypesToRemove.clear();\n    }\n\n    this.entitiesWithComponentsToRemove.clear();\n  }\n\n  /**\n   * Get a query based on a list of components\n   * @param componentConstructors List of components that will form the query\n   */\n  getQuery(componentConstructors: Components[]): Query {\n    return this.queryManager.getQuery(componentConstructors, this.entities);\n  }\n\n  // EXTRAS\n\n  /**\n   * Return number of entities\n   */\n  count(): number {\n    return this.entities.length;\n  }\n\n  /**\n   * Return some stats\n   */\n  stats() {\n    const stats = {\n      numEntities: this.entities.length,\n      numQueries: Object.keys(this.queryManager.queries).length,\n      queries: this.queryManager.stats(),\n      numComponentPool: Object.keys(this.componentManager.componentPool)\n        .length,\n      componentPool: {},\n      eventDispatcher: this.eventDispatcher.stats\n    };\n\n    for (const [cname, _] of this.componentManager.componentPool) {\n\n      const pool = this.componentManager.componentPool.get(cname);\n      stats.componentPool[cname.name] = {\n        used: pool.totalUsed(),\n        size: pool.count\n      };\n\n    }\n\n    return stats;\n  }\n}\n\n","import { Component, ComponentConstructor } from '../component.interface';\nimport { Resettable } from '../resettable.interface';\nimport { EntityManager } from './entity-manager';\nimport { Query, QueryEvents } from './query';\nimport { wrapImmutableComponent } from './wrap-immutable-component';\n\n// tslint:disable:no-bitwise\n\n// @todo Take this out from there or use ENV\nconst DEBUG = false;\n\nlet nextId = 0;\n\nexport class Entity implements Resettable {\n  // Unique ID for this entity\n  id = nextId++;\n\n  // List of components types the entity has\n  componentTypes = new Set<ComponentConstructor>();\n\n  // Instance of the components\n  components = new Map<string, Component>();\n\n  componentsToRemove = new Map<string, Component>();\n\n  // Queries where the entity is added\n  queries: Query[] = [];\n\n  // Used for deferred removal\n  componentTypesToRemove = new Set<ComponentConstructor>();\n\n  alive = false;\n\n  constructor(\n    public entityManager: EntityManager,\n  ) {}\n\n  // COMPONENTS\n\n  getComponent(componentConstructor: ComponentConstructor, includeRemoved?: boolean): Component {\n    let component = this.components.get(componentConstructor.name);\n\n    if (!component && includeRemoved === true) {\n      component = this.componentsToRemove.get(componentConstructor.name);\n    }\n\n    return DEBUG ? wrapImmutableComponent(component) : component;\n  }\n\n  getMutableComponent(componentConstructor: ComponentConstructor): Component {\n    const component = this.components.get(componentConstructor.name);\n\n    for (const query of this.queries) {\n\n      // @todo accelerate this check. Maybe having query._Components as an object\n      if (query.reactive && query.componentConstructors.indexOf(componentConstructor) !== -1) {\n        query.eventDispatcher.dispatchEvent(\n          QueryEvents.COMPONENT_CHANGED,\n          this,\n          component\n        );\n      }\n    }\n\n    return component;\n  }\n\n  /**\n   * Once a component is removed from an entity, it is possible to access its contents\n   */\n  getRemovedComponent(componentConstructor: ComponentConstructor): Component {\n    return this.componentsToRemove.get(componentConstructor.name);\n  }\n\n  getComponents(): Map<string, Component> {\n    return this.components;\n  }\n\n  getComponentsToRemove(): Map<string, Component> {\n    return this.componentsToRemove;\n  }\n\n  getComponentTypes(): Set<ComponentConstructor> {\n    return this.componentTypes;\n  }\n\n\n  addComponent(componentConstructor: ComponentConstructor, values?: { [key: string]: any }): this {\n    this.entityManager.entityAddComponent(this, componentConstructor, values);\n\n    return this;\n  }\n\n  /**\n   * This will mark the component to be removed and will populate all the queues from the\n   * systems that are listening to that event, but the component itself won't be disposed\n   * until the end of the frame, we call it deferred removal. This is done so systems that\n   * need to react to it can still access the data of the components.\n   */\n  removeComponent(componentConstructor: ComponentConstructor, forceRemove?: boolean): this {\n    this.entityManager.entityRemoveComponent(this, componentConstructor, forceRemove);\n\n    return this;\n  }\n\n  hasComponent(componentConstructor: ComponentConstructor, includeRemoved?: boolean): boolean {\n    return (\n      this.componentTypes.has(componentConstructor) ||\n      (includeRemoved === true && this.hasRemovedComponent(componentConstructor))\n    );\n  }\n\n  hasRemovedComponent(componentConstructor: ComponentConstructor): boolean {\n    return this.componentTypesToRemove.has(componentConstructor);\n  }\n\n  hasAllComponents(componentConstructors: ComponentConstructor[]): boolean {\n    for (const component of componentConstructors) {\n      if (!this.hasComponent(component)) { return false; }\n    }\n\n    return true;\n  }\n\n  hasAnyComponents(componentConstructors: ComponentConstructor[]): boolean {\n    for (const component of componentConstructors) {\n      if (this.hasComponent(component)) { return true; }\n    }\n\n    return false;\n  }\n\n  removeAllComponents(forceRemove?: boolean) {\n    return this.entityManager.entityRemoveAllComponents(this, forceRemove);\n  }\n\n  // EXTRAS\n\n  // Initialize the entity. To be used when returning an entity to the pool\n  reset() {\n    this.id = nextId++;\n    this.entityManager = null;\n    this.componentTypes.clear();\n    this.queries.length = 0;\n    this.components.clear();\n  }\n\n  remove(forceRemove?: boolean) {\n    return this.entityManager.removeEntity(this, forceRemove);\n  }\n}\n","\n/**\n * Components that extend the SystemStateComponent are not removed when an entity is deleted.\n *\n * System State Components (SSC) are components used by a system to hold internal resources\n * for an entity. They are not removed when you delete the entity, you must explicitly remove\n * them when you are done with them. They can be used to detect when an entity has been added\n * or removed from a query.\n */\nexport class SystemStateComponent {\n  static isSystemStateComponent = true;\n}\n\n","import { ComponentConstructor, Components } from '../component.interface';\nimport { queryKey } from '../utils';\nimport { Entity } from './entity';\nimport { Query } from './query';\n\n// tslint:disable:no-bitwise\n\n/**\n * QueryManager\n */\nexport class QueryManager {\n  // Queries indexed by a unique identifier for the components it has\n  queries = new Map<string, Query>();\n\n  constructor() {}\n\n  onEntityRemoved(entity: Entity): void {\n    for (const [_, query] of this.queries) {\n\n      if (entity.queries.indexOf(query) !== -1) {\n        query.removeEntity(entity);\n      }\n\n    }\n  }\n\n  /**\n   * Callback when a component is added to an entity\n   * @param entity Entity that just got the new component\n   * @param componentConstructor Component added to the entity\n   */\n  onEntityComponentAdded(entity: Entity, componentConstructor: ComponentConstructor): void {\n    // @todo Use bitmask for checking components?\n\n    // Check each indexed query to see if we need to add this entity to the list\n    for (const [_, query] of this.queries) {\n\n        if (\n          !!~query.notComponentConstructor.indexOf(componentConstructor) &&\n          ~query.entities.indexOf(entity)\n        ) {\n          query.removeEntity(entity);\n          continue;\n        }\n\n        // Add the entity only if:\n        // Component is in the query\n        // and Entity has ALL the components of the query\n        // and Entity is not already in the query\n        if (\n          !~query.componentConstructors.indexOf(componentConstructor) ||\n          !query.match(entity) ||\n          ~query.entities.indexOf(entity)\n        ) {\n          continue;\n        }\n\n\n\n        query.addEntity(entity);\n    }\n  }\n\n  /**\n   * Callback when a component is removed from an entity\n   * @param entity Entity to remove the component from\n   * @param componentConstructor Component to remove from the entity\n   */\n  onEntityComponentRemoved(entity: Entity, componentConstructor: ComponentConstructor): void {\n    for (const [_, query] of this.queries) {\n\n      if (\n        !!~query.notComponentConstructor.indexOf(componentConstructor) &&\n        !~query.entities.indexOf(entity) &&\n        query.match(entity)\n      ) {\n        query.addEntity(entity);\n        continue;\n      }\n\n      if (\n        !!~query.componentConstructors.indexOf(componentConstructor) &&\n        !!~query.entities.indexOf(entity) &&\n        !query.match(entity)\n      ) {\n        query.removeEntity(entity);\n        continue;\n      }\n\n    }\n  }\n\n  /**\n   * Get a query for the specified components\n   * @param componentConstructors Components that the query should have\n   */\n  getQuery(componentConstructors: Components[], entities: Entity[]): Query {\n    const key = queryKey(componentConstructors);\n\n    let query = this.queries.get(key);\n\n    if (!query) {\n      query = new Query(componentConstructors, entities, key);\n\n      this.queries.set(key, query);\n    }\n\n    return query;\n  }\n\n  /**\n   * Return some stats from this class\n   */\n  stats(): { [key: string]: Query; } {\n    const stats = {};\n    for (const [queryName, query] of this.queries) {\n\n      stats[queryName] = query.stats();\n    }\n\n    return stats;\n  }\n}\n","import { Components } from '../component.interface';\nimport { getName } from './get-name';\n\n/**\n * Get a key from a list of components\n * @param Components Array of components to generate the key\n */\nexport function queryKey(componentConstructor: Components[]) {\n  const names = [];\n\n  for (const T of componentConstructor) {\n    if (typeof T === 'object') {\n      const operator = T.operator === 'not' ? '!' : T.operator;\n      names.push(operator + getName(T.component));\n    } else {\n      names.push(getName(T));\n    }\n  }\n\n  return names.sort().join('-');\n}\n","import { ComponentConstructor } from '../component.interface';\r\nimport { EntityManager } from '../entity';\r\nimport { QueryEvents } from '../entity/query';\r\nimport { SystemConstructor } from '../system.interface';\r\nimport { canExecute } from './can-execute';\r\nimport { clearEvents } from './clear-events';\r\nimport { System } from './system';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\nexport class SystemManager {\r\n  systems = new Map<SystemConstructor<System>, System>();\r\n\r\n  // order is important\r\n  private executeSystems: System[] = []; // Systems that have `execute` method\r\n\r\n  lastExecutedSystem = null;\r\n\r\n  constructor(\r\n    private entityManager: EntityManager,\r\n  ) {}\r\n\r\n  registerSystem(systemConstructor: SystemConstructor<System>, attributes?: any) {\r\n    if (this.systems.has(systemConstructor)) {\r\n      console.warn(`System '${systemConstructor.name}' already registered.`);\r\n\r\n      return this;\r\n    }\r\n\r\n    const system = new systemConstructor();\r\n\r\n    // ----------\r\n\r\n    if (attributes && attributes.priority) {\r\n      system.priority = attributes.priority;\r\n    }\r\n\r\n\r\n\r\n    if (systemConstructor.queries) {\r\n      system.queriesOther = [];\r\n      system.queries = {};\r\n\r\n      for (const queryName in systemConstructor.queries) {\r\n        if (systemConstructor.queries.hasOwnProperty(queryName)) {\r\n\r\n          const queryConfig = systemConstructor.queries[queryName];\r\n\r\n          const components = queryConfig.components;\r\n\r\n          if (!components || components.length === 0) {\r\n            throw new Error('\\'components\\' attribute can\\'t be empty in a query');\r\n          }\r\n\r\n          const query = this.entityManager.getQuery(components);\r\n\r\n          system.queriesOther[queryName] = query;\r\n\r\n          if (queryConfig.mandatory === true) {\r\n            system.mandatoryQueries.push(query);\r\n          }\r\n\r\n          system.queries[queryName] = {\r\n            results: query.entities\r\n          };\r\n\r\n          const events = {\r\n            added: () => {\r\n              const eventList = (system.queries[queryName].added = []);\r\n\r\n              query.eventDispatcher.addEventListener(QueryEvents.ENTITY_ADDED,\r\n                (entity) => {\r\n\r\n                  // @fixme overhead?\r\n                  if (eventList.indexOf(entity) === -1) {\r\n\r\n                    eventList.push(entity);\r\n                  }\r\n                }\r\n              );\r\n            },\r\n            removed: () => {\r\n              const eventList = (system.queries[queryName].removed = []);\r\n\r\n              query.eventDispatcher.addEventListener(QueryEvents.ENTITY_REMOVED,\r\n                (entity) => {\r\n\r\n                  // @fixme overhead?\r\n                  if (eventList.indexOf(entity) === -1) {\r\n\r\n                    eventList.push(entity);\r\n                  }\r\n                }\r\n              );\r\n            },\r\n            changed: () => {\r\n              const event = queryConfig.listen.changed;\r\n\r\n              query.reactive = true;\r\n              if (event === true) {\r\n                // Any change on the entity from the components in the query\r\n                const eventList = (system.queries[queryName].changed = []);\r\n\r\n                query.eventDispatcher.addEventListener(\r\n                  QueryEvents.COMPONENT_CHANGED,\r\n                  (entity) => {\r\n                    // Avoid duplicates\r\n                    if (eventList.indexOf(entity) === -1) {\r\n                      eventList.push(entity);\r\n                    }\r\n                  }\r\n                );\r\n              } else if (Array.isArray(event)) {\r\n                const eventList = (system.queries[queryName].changed = []);\r\n\r\n                query.eventDispatcher.addEventListener(\r\n                  QueryEvents.COMPONENT_CHANGED,\r\n                  (entity, changedComponent) => {\r\n                    // Avoid duplicates\r\n                    if (\r\n                      event.indexOf(changedComponent.constructor as ComponentConstructor) !== -1 &&\r\n                      eventList.indexOf(entity) === -1\r\n                    ) {\r\n                      eventList.push(entity);\r\n                    }\r\n                  }\r\n                );\r\n              } else {\r\n                /*\r\n                // Checking just specific components\r\n                let changedList = (this.queries[queryName][eventName] = {});\r\n                event.forEach(component => {\r\n                  let eventList = (changedList[\r\n                    componentPropertyName(component)\r\n                  ] = []);\r\n                  query.eventDispatcher.addEventListener(\r\n                    Query.prototype.COMPONENT_CHANGED,\r\n                    (entity, changedComponent) => {\r\n                      if (\r\n                        changedComponent.constructor === component &&\r\n                        eventList.indexOf(entity) === -1\r\n                      ) {\r\n                        eventList.push(entity);\r\n                      }\r\n                    }\r\n                  );\r\n                });\r\n                */\r\n              }\r\n            }\r\n          };\r\n\r\n          if (queryConfig.listen) {\r\n            for (const eventName in queryConfig.listen) {\r\n              if (queryConfig.listen.hasOwnProperty(eventName) && events[eventName]) {\r\n                events[eventName]();\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----------\r\n\r\n    if (system.init) {\r\n      system.init();\r\n    }\r\n\r\n    system.order = this.systems.size;\r\n    this.systems.set(systemConstructor, system);\r\n\r\n    if (system.run) {\r\n      this.executeSystems.push(system);\r\n      this.sortSystems();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  sortSystems() {\r\n    this.executeSystems.sort((a, b) => {\r\n      return a.priority - b.priority || a.order - b.order;\r\n    });\r\n  }\r\n\r\n  getSystem(systemConstructor: SystemConstructor<System>): System {\r\n    return this.systems.get(systemConstructor);\r\n  }\r\n\r\n  getSystems(): Map<SystemConstructor<System>, System> {\r\n    return this.systems;\r\n  }\r\n\r\n  removeSystem(systemConstructor: SystemConstructor<System>): void {\r\n    this.systems.delete(systemConstructor);\r\n  }\r\n\r\n  runSystem(system: System): void {\r\n\r\n    if (system.initialized) {\r\n      if (canExecute(system)) {\r\n        const startTime = performance.now(); // ! debag performance\r\n\r\n        // main run;\r\n        system.run();\r\n\r\n        system.executeTime = performance.now() - startTime; // ! debag performance\r\n        this.lastExecutedSystem = system;\r\n\r\n        clearEvents(system);\r\n      }\r\n    }\r\n  }\r\n\r\n  stop(): void {\r\n    for (const system of this.executeSystems) {\r\n      system.stop();\r\n      system.executeTime = 0; // ! debag performance\r\n    }\r\n  }\r\n\r\n  run(forcePlay?: boolean): void {\r\n    for (const system of this.executeSystems) {\r\n      if (forcePlay || system.enabled) {\r\n        this.runSystem(system);\r\n      }\r\n    }\r\n  }\r\n\r\n  stats() {\r\n    const stats = {\r\n      numSystems: this.systems.size,\r\n      systems: {}\r\n    };\r\n\r\n    for (const system of this.systems) {\r\n      const systemStats = (stats.systems[system.constructor.name] = {\r\n        queries: {}\r\n      });\r\n\r\n      for (const name in (system as any).ctx) {\r\n        if ((system as any).ctx.hasOwnProperty(name)) {\r\n          systemStats.queries[name] = (system as any).ctx[name].stats();\r\n        }\r\n      }\r\n    }\r\n\r\n    return stats;\r\n  }\r\n}\r\n","import { System } from './system';\r\n\r\n\r\nexport const canExecute = (system: System) => {\r\n  if (system.mandatoryQueries.length === 0) { return true; }\r\n\r\n  for (const query of system.mandatoryQueries) {\r\n    if (query.entities.length === 0) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n","import { System } from './system';\r\n\r\nexport const clearEvents = (system: System) => {\r\n\r\n  for (const queryName in system.queries) {\r\n    if (system.queries.hasOwnProperty(queryName)) {\r\n\r\n      const query = system.queries[queryName];\r\n\r\n      if (query.added) {\r\n        query.added.length = 0;\r\n      }\r\n\r\n      if (query.removed) {\r\n        query.removed.length = 0;\r\n      }\r\n\r\n      if (query.changed) {\r\n        if (Array.isArray(query.changed)) {\r\n\r\n          query.changed.length = 0;\r\n\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n","import { Query } from '../system.interface';\nimport { Entity } from 'src/entity';\n\nexport interface ResultQuery {\n  [key: string]: {\n    /**\n     * All the entities with selected component\n     */\n    results: Entity[];\n    /**\n     * All the entities added to the query since the last call\n     */\n    added?: Entity[];\n    /**\n     * All the entities removed from the query since the last call\n     */\n    removed?: Entity[];\n    /**\n     * All the entities which selected components have changed since the last call\n     */\n    changed?: Entity[];\n  }\n}\n\n/**\n * A system that manipulates entities in the world.\n * Every run systems are executed and they create, remove or modify entities and components.\n */\nexport abstract class System {\n\n  static queries?: Query;\n\n  /**\n   * Whether the system will execute during the world tick.\n   */\n  enabled = true;\n  initialized = true;\n\n  queriesOther = {};\n  queries: ResultQuery = {};\n\n  mandatoryQueries = [];\n\n  priority = 0;\n  order = 0;\n\n  executeTime?: number;\n\n  /**\n   * It will get called each run by default (unless a custom scheduler is being used).\n   * Usually it will be used to loop through the lists of entities from each query and\n   * process the value of theirs components.\n   */\n  run?(): void;\n\n  /**\n   * This function is called when the system is registered in a world (Calling `world.registerSystem`)\n   * and can be used to initialize anything the system needs.\n   */\n  init?(): void;\n\n  /**\n   * Resume execution of this system.\n   */\n  play() {\n    this.enabled = true;\n  }\n\n  /**\n   * Stop execution of this system.\n   */\n  stop() {\n    this.enabled = false;\n  }\n}\n","import { ComponentManager } from './component';\r\nimport { ComponentConstructor } from './component.interface';\r\nimport { Entity, EntityManager } from './entity';\r\nimport { QueryManager } from './entity/query-manager';\r\nimport { System, SystemManager } from './system';\r\nimport { SystemConstructor } from './system.interface';\r\n\r\n/**\r\n * The World is the root of the ECS.\r\n */\r\nexport class World {\r\n\r\n  enabled = true;\r\n\r\n  eventQueues = {};\r\n\r\n  lastTime = performance.now();\r\n\r\n  /**\r\n   * Create a new World.\r\n   */\r\n  constructor(\r\n    public componentsManager = new ComponentManager(),\r\n    public entityManager = new EntityManager(componentsManager, new QueryManager()),\r\n    public systemManager = new SystemManager(entityManager),\r\n  ) {}\r\n\r\n  /**\r\n   * Register a component.\r\n   * @param component Type of component to register\r\n   */\r\n  registerComponent(component: ComponentConstructor): this {\r\n    this.componentsManager.registerComponent(component);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Register a system.\r\n   * @param system Type of system to register\r\n   */\r\n  registerSystem<T extends System>(system: SystemConstructor<T>, attributes?: any): this {\r\n    this.systemManager.registerSystem(system, attributes);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Get a system registered in this world.\r\n   * @param System Type of system to get.\r\n   */\r\n  getSystem<T extends System>(SystemClass: SystemConstructor<T>): System {\r\n    return this.systemManager.getSystem(SystemClass);\r\n  }\r\n\r\n  /**\r\n   * Get a list of systems registered in this world.\r\n   */\r\n  getSystems(): Map<SystemConstructor<any>, System> {\r\n    return this.systemManager.getSystems();\r\n  }\r\n\r\n  /**\r\n   * Update the systems.\r\n   */\r\n  run(): void {\r\n    if (this.enabled) {\r\n      this.systemManager.run();\r\n      this.entityManager.processDeferredRemoval();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop execution of this world.\r\n   */\r\n  stop(): void {\r\n    this.enabled = false;\r\n  }\r\n\r\n  /**\r\n   * Resume execution of this world.\r\n   */\r\n  play(): void {\r\n    this.enabled = true;\r\n  }\r\n\r\n  /**\r\n   * Create a new entity\r\n   */\r\n  createEntity(): Entity {\r\n    return this.entityManager.createEntity();\r\n  }\r\n\r\n  stats() {\r\n    const stats = {\r\n      entities: this.entityManager.stats(),\r\n      system: this.systemManager.stats()\r\n    };\r\n\r\n    console.log(JSON.stringify(stats, null, 2));\r\n  }\r\n}\r\n","/**\n * Create components that extend TagComponent in order to take advantage of performance optimizations for components\n * that do not store data\n */\nexport class TagComponent {\n  reset() {}\n}\n","\nexport interface TypeDefinition<T> {\n  baseType?: T;\n  isType?: boolean;\n  isSimpleType?: boolean;\n  create(defaultValue): void;\n  reset(src, key, defaultValue): void;\n  clear(src, key): void;\n  copy?(src, dst, key): void;\n}\n\nexport function createType<T>(typeDefinition: TypeDefinition<T>): TypeDefinition<T> {\n  const mandatoryFunctions = [\n    'create',\n    'reset',\n    'clear'\n    /*\"copy\"*/\n  ];\n\n  const undefinedFunctions = mandatoryFunctions.filter(f => {\n    return !typeDefinition[f];\n  });\n\n  if (undefinedFunctions.length > 0) {\n    throw new Error(\n      `createType expect type definition to implements the following functions: ${undefinedFunctions.join(\n        ', '\n      )}`\n    );\n  }\n\n  typeDefinition.isType = true;\n\n  return typeDefinition;\n}\n","import { createType } from './create-type';\n\n/**\n * Standard types\n */\nexport const standardTypes = {\n  number: createType({\n    baseType: Number,\n    isSimpleType: true,\n    create: defaultValue => {\n      return typeof defaultValue !== 'undefined' ? defaultValue : 0;\n    },\n    reset: (src, key, defaultValue) => {\n      if (typeof defaultValue !== 'undefined') {\n        src[key] = defaultValue;\n      } else {\n        src[key] = 0;\n      }\n    },\n    clear: (src, key) => {\n      src[key] = 0;\n    }\n  }),\n  boolean: createType({\n    baseType: Boolean,\n    isSimpleType: true,\n    create: defaultValue => {\n      return typeof defaultValue !== 'undefined' ? defaultValue : false;\n    },\n    reset: (src, key, defaultValue) => {\n      if (typeof defaultValue !== 'undefined') {\n        src[key] = defaultValue;\n      } else {\n        src[key] = false;\n      }\n    },\n    clear: (src, key) => {\n      src[key] = false;\n    }\n  }),\n  string: createType({\n    baseType: String,\n    isSimpleType: true,\n    create: defaultValue => {\n      return typeof defaultValue !== 'undefined' ? defaultValue : '';\n    },\n    reset: (src, key, defaultValue) => {\n      if (typeof defaultValue !== 'undefined') {\n        src[key] = defaultValue;\n      } else {\n        src[key] = '';\n      }\n    },\n    clear: (src, key) => {\n      src[key] = '';\n    }\n  }),\n  array: createType({\n    baseType: Array,\n    create: defaultValue => {\n      if (typeof defaultValue !== 'undefined') {\n        return defaultValue.slice();\n      }\n\n      return [];\n    },\n    reset: (src, key, defaultValue) => {\n      if (typeof defaultValue !== 'undefined') {\n        src[key] = defaultValue.slice();\n      } else {\n        src[key].length = 0;\n      }\n    },\n    clear: (src, key) => {\n      src[key].length = 0;\n    },\n    copy: (src: any, dst: any, key: string) => {\n      src[key] = dst[key].slice();\n    }\n  }),\n};\n\n","import { TypeDefinition } from './create-type';\nimport { standardTypes } from './standard-types';\n\n/**\n * Try to infer the type of the value\n * @return Type of the attribute\n */\nexport function inferType(value: unknown): TypeDefinition<NumberConstructor | BooleanConstructor | BooleanConstructor | ArrayConstructor> {\n  if (Array.isArray(value)) {\n    return standardTypes.array;\n  } else if (standardTypes[typeof value]) {\n    return standardTypes[typeof value];\n  } else {\n    return null;\n  }\n}\n","import { ComponentConstructor } from './component.interface';\n\n/**\n * Use the Not class to negate a component query.\n */\nexport const Not = (component: ComponentConstructor): NotComponent => ({\n  operator: 'not',\n  component,\n});\n\nexport interface NotComponent {\n  operator: 'not';\n  component: ComponentConstructor;\n}\n","import { ComponentConstructor } from '../component.interface';\nimport { inferType } from './infer-type';\n\nexport function createComponentClass(schema: any, name: string): ComponentConstructor {\n  // var Component = new Function(`return function ${name}() {}`)();\n\n  for (const key in schema) {\n    if (schema.hasOwnProperty(key)) {\n\n      const type = schema[key].type;\n      if (!type) {\n        schema[key].type = inferType(schema[key].default);\n      }\n    }\n  }\n\n  const Component = function() {\n    for (const key in schema) {\n      if (schema.hasOwnProperty(key)) {\n\n        const attr = schema[key];\n        const type = attr.type;\n        if (type && type.isType) {\n          this[key] = type.create(attr.default);\n        } else {\n          this[key] = attr.default;\n        }\n\n      }\n    }\n  };\n\n  if (typeof name !== 'undefined') {\n    Object.defineProperty(Component, 'name', { value: name });\n  }\n\n  Component.prototype.schema = schema;\n\n  let knownTypes = true;\n  for (const key in schema) {\n    if (schema.hasOwnProperty(key)) {\n\n      const attr = schema[key];\n      if (!attr.type) {\n        attr.type = inferType(attr.default);\n      }\n\n      const type = attr.type;\n      if (!type) {\n        console.warn(`Unknown type definition for attribute '${key}'`);\n        knownTypes = false;\n      }\n\n    }\n  }\n\n  if (!knownTypes) {\n    console.warn(\n      `This component can't use pooling because some data types are not registered. Please provide a type created with 'createType'`\n    );\n\n    for (const key in schema) {\n      if (schema.hasOwnProperty(key)) {\n\n        const attr = schema[key];\n        Component.prototype[key] = attr.default;\n\n      }\n    }\n  } else {\n    Component.prototype.copy = function(src) {\n\n      for (const key in schema) {\n        if (src[key]) {\n          const type = schema[key].type;\n          if (type.isSimpleType) {\n            this[key] = src[key];\n          } else if (type.copy) {\n            type.copy(this, src, key);\n          } else {\n            // @todo Detect that it's not possible to copy all the attributes\n            // and just avoid creating the copy function\n            console.warn(\n              `Unknown copy function for attribute '${key}' data type`\n            );\n          }\n        }\n      }\n    };\n\n    Component.prototype.reset = function() {\n      for (const key in schema) {\n        if (schema.hasOwnProperty(key)) {\n\n          const attr = schema[key];\n          const type = attr.type;\n          if (type.reset) { type.reset(this, key, attr.default); }\n\n        }\n      }\n    };\n\n    Component.prototype.clear = function() {\n      for (const key in schema) {\n        if (schema.hasOwnProperty(key)) {\n\n          const type = schema[key].type;\n          if (type.clear) { type.clear(this, key); }\n\n        }\n      }\n    };\n\n    for (const key in schema) {\n      if (schema.hasOwnProperty(key)) {\n\n        const attr = schema[key];\n        const type = attr.type;\n        Component.prototype[key] = attr.default;\n\n        if (type.reset) {\n          type.reset(Component.prototype, key, attr.default);\n        }\n\n      }\n    }\n  }\n\n  return Component as any;\n}\n"],"names":["objectConstructor","initialSize","this","extraArgs","arguments","length","Array","prototype","slice","call","shift","createElement","expand","ObjectPool","freeList","Math","round","count","pop","item","reset","push","n","DummyObjectPool","used","Infinity","Set","Map","ComponentManager","componentConstructor","componentConstructors","has","console","warn","name","add","registerComponent","componentPool","set","get","getName","QueryEvents","fired","handled","EventDispatcher","eventName","listener","listeners","listenerArray","indexOf","undefined","index","splice","entity","component","stats","array","array_1","__values","EntityManagerEvents","entities","key","forEach","_this","notComponentConstructor","Error","entities_1","match","queries","Query","eventDispatcher","dispatchEvent","ENTITY_ADDED","ENTITY_REMOVED","hasAllComponents","hasAnyComponents","reactive","components","included","map","C","not","numEntities","numComponents","nextId","entityManager","Entity","includeRemoved","componentsToRemove","_b","query","COMPONENT_CHANGED","componentTypes","values","entityAddComponent","forceRemove","entityRemoveComponent","hasRemovedComponent","componentTypesToRemove","componentConstructors_1","hasComponent","componentConstructors_2","entityRemoveAllComponents","id","clear","removeEntity","SystemStateComponent","componentManager","queryManager","EntityManager","entityPool","aquire","alive","ENTITY_CREATED","__proto__","numStateComponents","componentFromPool","getComponentsPool","copy","hasOwnProperty","onEntityComponentAdded","componentAddedToEntity","COMPONENT_ADDED","immediately","COMPONENT_REMOVE","entityRemoveComponentSync","size","entitiesWithComponentsToRemove","delete","componentName","onEntityComponentRemoved","remove","componentEntity","release","componentType","onEntityRemoved","releaseEntity","entitiesToRemove","i","deferredRemovalEnabled","_d","_f","_h","componentTypeToRemove","getQuery","numQueries","Object","keys","numComponentPool","cname","pool","totalUsed","QueryManager","addEntity","names","componentConstructor_1","T","operator","sort","join","queryKey","queryName","SystemManager","systemConstructor","attributes","systems","system","priority","queriesOther","queryConfig_1","query_1","this_1","mandatory","mandatoryQueries","results","events","added","eventList","addEventListener","removed","changed","event","listen","eventList_1","isArray","eventList_2","changedComponent","constructor","init","order","run","executeSystems","sortSystems","a","b","initialized","canExecute","startTime","performance","now","executeTime","lastExecutedSystem","clearEvents","stop","forcePlay","enabled","runSystem","numSystems","systemStats","ctx","System","componentsManager","systemManager","World","registerSystem","SystemClass","getSystem","getSystems","processDeferredRemoval","createEntity","log","JSON","stringify","TagComponent","createType","typeDefinition","undefinedFunctions","filter","f","isType","standardTypes","number","baseType","Number","isSimpleType","create","defaultValue","src","boolean","Boolean","string","String","dst","inferType","value","schema","type","default","Component","attr","defineProperty","knownTypes"],"mappings":"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"}